#!/usr/bin/env python
# encoding: utf-8

APPNAME = 'projectname'
VERSION = waflib.Utils.readf('version.txt')


def options(opt):
    opt.load('compiler_cxx')


def configure(conf):
    conf.load('compiler_cxx')
    # This makes sure that autorevision exists before we call it.
    ctx.find_program('autorevision', var='AUTOREVISION')


def build(bld):

    # Here we let waf know about the autorevision.cache file.
    autorevision_cache_node = bld.path.find_or_declare('autorevision.cache')

    # This is where the cache file is made.
    bld(
        name='autorevision',
        rule='autorevision -s VCS_TAG -o ${TGT[0].abspath()}',
        target=autorevision_cache_node,
        always=True,
        update_outputs = True)

    # This is where the version.txt file is created.
    bld(
        name='version',
        after='autorevision',
        rule='autorevision -f -s VCS_TAG -o ${SRC[0].abspath()} > ${TGT}',
        source=autorevision_cache_node,
        target='version.txt')

    # This is where the autorevision.json file is made.
    bld(
        after='autorevision',
        rule='${AUTOREVISION} -f -t json -o ${SRC[0].abspath()} > ${TGT}',
        source=autorevision_cache_node,
        target='autorevision.json')

    # This is where the autorevision.h file is made.
    bld(
        after='autorevision',
        rule='${AUTOREVISION} -f -t h -o ${SRC[0].abspath()} > ${TGT}',
        source=autorevision_cache_node,
        target='autorevision.h')
